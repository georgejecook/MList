import "pkg:/source/roku-list/ListItemScroller.bs"
import "pkg:/source/roku_modules/mc/Tasks.brs"

function init()
  log_registerLogger("List")
  m.rowsGroup = m.top.findNode("rowsGroup") 
  m.moveAnimationInterpolator = m.top.findNode("moveAnimationInterpolator") 
  m.moveAnimation = m.top.findNode("moveAnimation") 
  m.itemScroller = new ListItemScroller(m.rowsGroup, 1, 0, 1080, m.moveAnimation, m.moveAnimationInterpolator)

  ' m.top.clippingRect = [0,0,1920,550]
  m.overlay = m.top.findNode("overlay") 
  m.focusTimer = m.top.findNode("focusTimer") 
  m.cellProvider = m.global.cellProvider
  m.cellTracker = m.global.cellTracker
  m.content = invalid
  m.numberOfRowsToShow = 3
  m.top.rowFocused = 0
  m.visibleLists = []
  m.hiddenLists = []
  m.lists = []
  m.lastStates = {}
  m.content = invalid
  m.focusTimer.observeField("fire", "currFocusItemIndexChanged")
  resetState()
end function

function resetState()
  m.currentY = 0
  m.listIndex = 0
  m.rowsGroup.removeChildren(m.rowsGroup.getChildren(-1, 0))

  m.lists = []

  if m.content <> invalid
    for each item in m.content.getChildren(-1, 0)
      if item.cellType <> invalid and item.cellType = "RectComp"
        list = makeRectComp(item)
      else
        list = makeList(item)
      end if
      m.lists.push(list)
    end for
  end if

  'TODO - MU namespace not resolving - INVESTIGATE
  addListListeners()
  m.currentList = m.visibleLists[m.top.rowFocused]
  m.itemScroller.moveYFocus(0)
  setInitialTimer = m.top.findNode("setInitialTimer")
  setInitialTimer.observeField("fire", "onSetInitialTimerFire")
  setInitialTimer.control = "start"
  m.itemScroller.updateRowFocus(0)
end function

function onSetInitialTimerFire()
  m.logMethod(">>onSetInitialTimerFire")
  layoutLists()
  for each row in m.visibleLists
    ' row.viewState = "partial"
    row.viewState = "hidden"
  end for
  m.itemScroller.updateRowStates(0, 0, 5, 10)
end function

function layoutLists()
  m.currentY = 0

  m.visibleLists = []
  m.hiddenLists = []
  m.itemRects = []
  for each list in m.lists
    list.visible = not list.isHidden
    if list.visible
      list.translation = [0, m.currentY]
      if list.subType() = "Rectangle"
        m.currentY += list.height + 40
      else
        m.currentY += m.top.cellSize[1] + m.top.cellSpacing[1] + 40
      end if
      m.visibleLists.push(list)
    else
      m.hiddenLists.push(list)
    end if
  end for

  m.itemScroller.updateItems(m.visibleLists)
end function

function layoutCells()
  cw = m.top.cellSize[0]
  ch = m.top.cellSize[1]
  csw = m.top.cellSpacing[0]
  csh = m.top.cellSpacing[1]
  m.rects = []
  'rects.push({ x: - cw, y: 0, width: cw, height: ch })
  content = m.top.content
  numCells = content.getChildCount()
  createHorizontalRects(m.rects, 0, cw, ch, csw, csh, numCells)
end function

function createHorizontalRects(rects, sx, cw, ch, csw, csh, numberOfCols)
  w = sx
  y = csh
  for i = 0 to numberOfCols
    rects.push({ x: w, y: y, width: cw, height: ch })
    w += cw + csw
  end for
end function



function onContentChange()
  if m.content = invalid or not m.content.isSameNode(m.top.content)
    m.content = m.top.content
    resetState()
  end if
end function

function onAnimateToRowChange()
  if m.content <> invalid
    ' animateToIndex(m.top.rowFocused, m.top.animateToRow, m.top.fastAnimationSpeed)
    m.itemScroller.animateToIndex(m.top.animateToRow, m.top.fastAnimationSpeed)
  end if
end function

function makeList(rowContent)
  list = m.rowsGroup.createChild("HorizontalRow")
  list.id = str(m.listIndex).trim()
  list.cellSize = m.top.cellSize
  list.cellSpacing = m.top.cellSpacing
  list.numCols = m.top.numCols
  list.unfocusCellScale = m.top.unfocusCellScale
  list.unfocusCount = m.top.unfocusCount
  list.viewState = "hidden"
  list.content = rowContent
  list.isOnScreen = m.listIndex < 5
  m.listIndex++

  return list
end function

function makeRectComp(rowContent)
  list = m.rowsGroup.createChild("Rectangle")
  list.id = str(m.listIndex).trim()
  list.color = "#aaffaa"
  list.addFields({ "content": rowContent })
  list.addFields({ "isFocusable": true })
  list.addFields({ "isHidden": false })
  list.addFields({ "isFocused": false })
  list.width = 1920
  list.height = 300
  list.content = rowContent
  m.listIndex++

  return list
end function

function addListListeners()
  for each list in m.visibleLists
    list.observeField("itemFocused", "itemFocusedChanged")
    list.observeField("itemUnfocused", "itemUnfocusedChanged")
    list.observeField("itemSelected", "itemSelectedChanged")
    ' list.observeField("currFocusItemIndex", "currFocusItemIndexChanged")
    list.observeField("isHidden", "onListIsHiddenChange")
    list.observeField("isFocusable", "onListIsFocuableChange")
    list.observeField("currTarget", "onCurrTargetChange")
  end for
end function

function itemFocusedChanged()
  m.top.itemFocused = m.currentList.itemFocused
end function

function itemUnfocusedChanged()
  m.top.itemUnfocused = m.currentList.itemUnfocused
end function

function itemSelectedChanged()
  m.top.itemSelected = m.currentList.itemSelected
end function

function currFocusItemIndexChanged() 
  ' ? "currFocusItemIndexChanged " ; 
  list = m.visibleLists[m.top.rowFocused]
  if list <> invalid and list.subType() = "HorizontalRow"
    index = list.currFocusItemIndex
    m.top.currFocusItemIndex = index
    rect = getBoundsForIndex(m.top.rowFocused, int(index))

    if rect <> invalid
      ' ? " rect is "; formatJson(rect)
      m.overlay.width = rect.height
      m.overlay.height = rect.width
      yOffset = list.translation[1] + m.rowsGroup.translation[1]

      'floating
      ' if m.list.content.yOffset <> invalid
      '   yOffset -= m.currentList.content.yOffset 
      ' end if
      m.overlay.translation = [rect.x, rect.y + yOffset]
    else
      ? " no rect for focused item"
    end if
  end if
end function

function onListIsHiddenChange(evt)
  layoutLists()
end function

function onListIsFocuableChange(evt)
  'TODO update focus if we're currently focused on the list
end function

function onCurrTargetChange(evt)
  currTarget = m.currentList.currTarget
  ' ? "currTargetSet"; formatJson(currTarget)
end function

function getBoundsForIndex(rowIndex, index)
  rect = invalid
  list = m.visibleLIsts[rowIndex]
  if list <> invalid and list.subType() = "HorizontalRow"
    set = list.currTargetSet
    ' ? " set.focusIndex " ; set.focusIndex + list.focusIndexOffset
    if set <> invalid
      return set[index]
    end if
  end if

  if rect <> invalid
    ' ? "INDEX" ; index ; " " ; formatJson(dynamicCell.boundingRect()); "  " ; formatJson(dynamicCell.localBoundingRect()); "  " ; formatJson(dynamicCell.sceneBoundingRect()); "  " 
    return rect
  else
    ? "could not find target "
    return {
      width: 0
      height: 0
      translation: [0, 0]
    }
  end if

end function

function isHiddenChange()
  ? "ishiddenchange"
  if m.top.isHidden
    for each rowId in m.laststates
      list = m.visibleLists[rowId.toInt()]
      if list <> invalid
        list.viewState = "hidden"
      else
        ? "ERROR could not find visible list for "; rowId
      end if
    end for
  else
    for each rowId in m.laststates
      list = m.visibleLists[rowId.toInt()]
      if list <> invalid
        list.viewState = m.laststates[rowId]
      else
        ? "ERROR could not find visible list for "; rowId
      end if
    end for

  end if

end function

function getFocusedBounds()
  return getBoundsForIndex(m.top.rowFocused, int(m.currentList.currFocusItemIndex))
end function

'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++ KeyPress
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function onKeyPressUp() as boolean
  m.logMethod("onKeyPressUp")
  m.itemScroller.move(-1)
  return true
end function

function onKeyPressDown() as boolean
  m.logMethod("onKeyPressDown")
  m.itemScroller.move(1)
  return true
end function

function getLongPressIntervalForKey(key) as float
  m.logMethod("getLongPressIntervalForKey", key)
  if key = "up" or key = "down"
    return 0.5
  else
    return 0
  end if
end function

function onLongPressStart(key) as boolean
  m.logMethod(">>>>onLongPressStart", key)

  if key = "up" or key = "down"
    m.logVerbose("long press finished on key", key, "going to animate to final scroll position")
    if key = "up"
      targetIndex = 0 
    else
      targetIndex = m.visibleLists.count() - 1
    end if

    m.itemScroller.animateToIndex(m.top.rowFocused, targetIndex)
    return true
  end if

  return false
end function

function onLongPressFinish(key) as boolean
  if key = "up" or key = "down"
    'fixed focus 
    m.logVerbose("long press finished on key", key, "going to animate to final scroll position")
    m.itemScroller.finishAnimating()
    return true
  end if

  return false
end function

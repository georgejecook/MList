import "pkg:/source/roku-list/ListMixin.bs"
import "pkg:/source/roku-list/ListDelegateMixin.bs"
import "pkg:/source/roku-list/ListItemScroller.bs"
import "pkg:/source/roku-list/RowItemViewManager.bs"
import "pkg:/source/roku-list/ItemFocusManager.bs"

function init()
  log_registerLogger("List")
  m.top.observeField("content", "onContentChange")

  m.cellsGroup = m.top.findNode("cellsGroup")
  m.moveAnimationInterpolator = m.top.findNode("moveAnimationInterpolator") 
  m.moveAnimation = m.top.findNode("moveAnimation")

  ' m.top.focusMoveAnimationInterpolator = m.top.findNode("focusMoveAnimationInterpolator") 
  ' m.top.focusMoveAnimation = m.top.findNode("focusMoveAnimation")
  ' m.viewManager = new RowItemViewManager(m.top, m.rowsGroup)
  ' m.focusManager = new ItemFocusManager(m.viewManager, m.top.focusMoveAnimation, m.top.focusMoveAnimationInterpolator)
  ' m.itemScroller = new ListItemScroller(m.viewManager, 1, 0, 1080, m.moveAnimation, m.moveAnimationInterpolator)
  ' m.itemScroller.focusManager = m.focusManager

  ' m.moveAnimationInterpolator = m.top.findNode("moveAnimationInterpolator") 
  ' m.moveAnimation = m.top.findNode("moveAnimation") 
  ' m.moveAnimationInterpolator.observeField("fraction", "onAnimationFractionChange")

  ' m.header = m.top.findNode("header")
  ' m.cellProvider = m.global.cellProvider
  ' m.cellTracker = m.global.cellTracker
  ' m.cellsById = {}
  ' m.currentDirection = 0
  ' m.previousscreenState = ""
  ' m.content = invalid
  ' ListItemDelegateMixin.setDelegate()
end function



' function onContentIsHiddenChange()
'   m.top.isHidden = m.content.isHidden = true
' end function

function onContentChange(evt)
  ' m.logInfo("onContentChange", evt.getField())
  if m.content = invalid or not m.content.isSameNode(m.top.content)
    m.content = m.top.content
    calculateHeight()
    ' if m.content.isHidden <> true
    '   ' configureHeader()
    '   ' if m.content.focusType <> invalid
    '   '   m.top.focusType = m.content.focusType
    '   ' end if
    '   ' toggleContentListener(true)
    '   ' layoutCells()
    '   ' onscreenStateChange()
    ' else
    ' end if
  end if
end function

function calculateHeight()
  settings = ListMixin.getRowSettings(m.top.owner, m.content)
  if settings.height <> -1
    m.top.height = settings.height
  else
    m.top.height = settings.cellSettings.size[1]
  end if
end function

' function configureHeader()
'   if m.content <> invalid
'     m.header.text = m.content.title
'   else
'     m.header.text = ""
'   end if
' end function

' function createHorizontalRects(rects, sx, cw, ch, csw, csh, numberOfCols)
'   w = sx
'   y = csh
'   for i = 0 to numberOfCols
'     rects.push({ translation: [w,y], size: [cw, ch] })
'     w += cw + csw
'   end for
' end function

' function layoutCells()
'   cw = m.top.cellSize[0]
'   ch = m.top.cellSize[1]
'   csw = m.top.cellSpacing[0]
'   csh = m.top.cellSpacing[1]
'   m.rects = []
'   'rects.push({ x: - cw, y: 0, width: cw, height: ch })
'   content = m.top.content
'   numCells = content.getChildCount()
'   createHorizontalRects(m.rects, 0, cw, ch, csw, csh, numCells)

'   'create all the content 
'   ' for i = 0 to numCells
'   '   cell = m.cellsGroup.createChild("DynamicCell")
'   '   cell.index = i
'   '   cell.itemContent = content.getChild(i)
'   '   currRect = m.rects[i]
'   '   cell.currRect = currRect
'   '   cell.translation = [currRect.x, currRect.y]
'   ' end for
'   m.top.currTargetSet = m.rects
'   'updateListVisibility(m.top.screenState)
' end function

' function animateToIndex(oldIndex, index, fastAnimationSpeed = 1)
'   m.logMethod("animateToIndex from", oldIndex, "to", index)
'   nextCell = m.rects[index]

'   if nextCell = invalid
'     m.logError("could not idenitfy next cell with index", index)
'     return invalid
'   end if

'   targetX = getItemFocusXPosition(index)
'   'TODO count visible rows between oldIndex and newIndex
'   steps = abs(oldIndex - index)
'   if m.moveAnimation.state = "play"
'     m.moveAnimation.control = "pause"
'   end if
'   m.moveAnimationInterpolator.keyValue = [[m.cellsGroup.translation[0], 20], [- targetX, 20]]
'   m.moveAnimation.duration = (steps * m.top.animSpeed) / fastAnimationSpeed


'   if m.top.screenState <> "onScreen"
'     m.top.screenState = "onScreen"
'   end if

'   if m.moveAnimation.state = "pause"
'     m.moveAnimation.control = "resume"
'   else
'     m.moveAnimation.control = "start"
'   end if

' end function

' function onAnimateToItemChange()
'   if m.content <> invalid
'     ' m.logInfo("onAnimateToItemChange", m.top.animateToItem)
'     animateToIndex(m.top.itemFocused, m.top.animateToItem, m.top.fastAnimationSpeed)
'   end if
' end function

' function getIndexAtX(xPos)
'   for i = 0 to m.rects.count() - 1
'     x = getItemFocusXPosition(i)
'     if abs(x) >= abs(xPos)
'       return i
'     end if
'   end for

'   return -1
' end function

' function getItemFocusXPosition(index) 
'   rect = m.rects[index] 
'   if rect <> invalid
'     return rect.translation[0]
'   end if
'   return 0
' end function

' function onAnimationFractionChange()
'   x = m.cellsGroup.translation[0]
'   index = getIndexAtX(x)
'   ' m.logInfo("onAnimationFractionChange", m.moveAnimationInterpolator.fraction, "x", x, "index", index)

'   if m.moveAnimationInterpolator.fraction = 1
'     if index = -1
'       index = 0
'     end if
'     m.top.itemFocused = index
'     if m.top.screenState = "onScreen"
'       m.top.screenState = "buffer"
'     end if
'   els
'     'updating horizontal list efficiency while scrolling..
'     if index <> -1 and index <> m.top.rowFocused
'       updateListVisibility("onScreen")
'     end if
'     m.top.itemFocused = index

'   end if

' end function

' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
' '++ flyweight heuristics (i.e. cell reuse)
' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

' function onscreenStateChange()
'   ' m.logInfo("onscreenStateChange", m.top.index, m.top.screenState)
'   if m.top.screenState <> m.previousscreenState 
'     m.previousscreenState = m.top.screenState
'     updateListVisibility(m.top.screenState)
'   end if
' end function

' function updateListVisibility(state)
'   if m.content <> invalid
'     ' m.logMethod("updateListVisibility", m.top.index, state)
'     states = {}

'     if state = "offScreen" or state = "buffer"
'       setListStateMap(states, 0, m.content.getChildCount(), "offScreen")
'     end if

'     if state = "onScreen"
'       ' setListStateMap(states, 0, m.content.getChildCount(), "onScreen")
'       setListStateMap(states, m.top.itemFocused - 1, m.top.itemFocused + 4, "onScreen")
'     else if state = "buffer"
'       'TODO - calcculate this!
'       setListStateMap(states, m.top.itemFocused - 1, m.top.itemFocused + 4, "onScreen")
'     end if

'     toggleCellStates(states)
'   end if
' end function

' function setListStateMap(states, startIndex, endIndex, state)
'   ' m.logMethod("setListStateMap", startIndex, endIndex, state)
'   for i = startIndex to endIndex

'     if i >= 0 and i < m.content.getChildCount()
'       states[str(i).trim()] = state
'     end if
'   end for
' end function

' function toggleCellStates(states)
'   'm.cellTracker.callFunc("setscreenStates", states)
'   for each id in states
'     applyscreenStateForCell(id, states[id])
'   end for
' end function

' function onIsOnScreenChange()
'   ' m.logMethod("onIsOnScreenChange")
'   isOnScreen = m.top.isOnScreen
'   for each id in m.cellsById
'     cell = m.cellsById[id]
'     if isOnScreen
'       cell.itemContent = m.content.getChild(id.toInt())
'     end if
'     cell.visible = isOnScreen
'   end for
' end function

' function applyscreenStateForCell(id, screenState)
'   index = id.toInt()
'   isOnScreen = m.top.isOnScreen
'   ' ? "applyscreenStateForCell "; id ; " vs " ; screenState ; " isonScreen" ; isOnScreen
'   item = m.content.getChild(index)
'   if item <> invalid
'     if screenState = "onScreen"
'       if m.cellsById[id] = invalid
'         cell = m.cellProvider@.getCell(item.cellType)
'         if cell <> invalid
'           cell.visible = isOnScreen

'           if isOnScreen
'             cell.itemContent = item
'           end if

'           cell.translation = m.rects[index]
'           m.cellsGroup.appendChild(cell)
'           cell.index = m.top.index
'           m.cellsById[id] = cell
'         else 
'           ? ">>ERR no cell for " ; item.cellType
'         end if
'       end if
'     else
'       cell = m.cellsById[id]
'       if cell <> invalid
'         m.cellProvider@.releaseCell(cell) 
'         m.cellsById.delete(id)
'       end if
'     end if
'   end if
' end function

' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
' '++ lifecycle
' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

' function onCurrFocusItemIndexChange()
' end function

' function onIsFocusedChange()
' end function

' function moveXFocus(direction)
'   nextIndex = m.top.itemFocused + direction

'   if nextIndex < 0
'     nextIndex = 0
'   else if nextIndex > m.rects.count() - 1
'     nextIndex = m.rects.count() - 1
'   end if
'   animateToIndex(m.top.itemFocused, nextIndex)
'   m.top.itemFocused = nextIndex

' end function

' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
' '++ KeyPress
' '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

' function onKeyPressLeft() as boolean
'   m.logMethod("onKeyPressLeft")
'   moveXFocus(-1)
'   return true
' end function

' function onKeyPressRight() as boolean
'   m.logMethod("onKeyPressRight")
'   moveXFocus(1)
'   return true
' end function


' function getLongPressIntervalForKey(key) as float
'   m.logMethod("getLongPressIntervalForKey", key)
'   if key = "left" or key = "right"
'     return 0.5
'   else
'     return 0
'   end if
' end function

' function onLongPressStart(key) as boolean
'   m.logMethod(">>>>onLongPressStart", key)

'   if key = "left" or key = "right"
'     m.logVerbose("long press finished on key", key, "going to animate to final scroll position")
'     if key = "left"
'       targetIndex = 0 
'     else
'       targetIndex = m.content.getChildCount() - 1
'     end if
'     animateToIndex(m.top.itemFocused, targetIndex)
'     return true
'   end if

'   return false
' end function

' function onLongPressFinish(key) as boolean
'   if key = "left" or key = "right"
'     'fixed focus 
'     m.logVerbose("long press finished on key", key, "going to animate to final scroll position")
'     index = getIndexAtX(m.cellsGroup.translation[0])
'     if m.currentDirection = -1
'       nextIndex = index - 1
'     else
'       nextIndex = index
'       index -= m.currentDirection
'     end if

'     if nextIndex < 0
'       nextIndex = 0
'     else if index > m.rects.count() - 1
'       nextIndex = m.rects.count() - 1
'     end if

'     animateToIndex(index, nextIndex)
'     return true
'   end if

'   return false
' end function


'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++ delegate
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function onWillEnter(index, direction)
  ? "onWillEnter " ; index ; " " ; direction
end function

function onWillExit(index, direction)
  ? "onWillExit " ; index ; " " ; direction
end function

function onDidEnter(index, direction)
  ? "onDidEnter " ; index ; " " ; direction
end function

function onDidExit(index, direction)
  ? "onDidExit " ; index ; " " ; direction
end function

function onWillGainFocus(index, direction)
  ? "onWillGainFocus " ; index ; " " ; direction
end function

function onWillListFocus(index, direction)
  ? "onWillListFocus " ; index ; " " ; direction
end function

function onDidGainFocus(index, direction)
  ? "onDidGainFocus " ; index ; " " ; direction
end function

function onDidLoseFocus(index, direction)
  ? "onDidLoseFocus " ; index ; " " ; direction
end function

function onGainingFocus(index, direction, fraction)
  ? "onGainingFocus " ; index ; " " ; direction ; " f " ; fraction
end function

function onLosingFocus(index, direction, fraction)
  ? "onLosingFocus " ; index ; " " ; direction ; " f " ; fraction
end function
